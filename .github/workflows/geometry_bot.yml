#!/usr/bin/env python3
"""
Geometry Bot v3.0 - Cairo Tabanlı Profesyonel Görselleştirme
============================================================
Geometri şekilleri, 3D pasta grafiği, sütun grafiği
GitHub Actions uyumlu
"""

import os
import io
import json
import math
import time
import logging
from datetime import datetime
from typing import Optional, Dict, List, Tuple

import cairo
import numpy as np
from supabase import create_client, Client

try:
    from google import genai
    NEW_GENAI = True
except ImportError:
    import google.generativeai as genai
    NEW_GENAI = False

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class Config:
    SUPABASE_URL = os.environ.get('SUPABASE_URL')
    SUPABASE_KEY = os.environ.get('SUPABASE_KEY')
    GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
    # Alternatif modeller: gemini-2.0-flash-exp, gemini-1.5-flash, gemini-1.5-pro
    GEMINI_MODEL = os.environ.get('GEMINI_MODEL', 'gemini-2.0-flash-exp')
    STORAGE_BUCKET = 'questions-images'
    # Rate limit nedeniyle batch size düşük tutulmalı (dakikada max 10 istek)
    BATCH_SIZE = int(os.environ.get('BATCH_SIZE', '10'))
    TEST_MODE = os.environ.get('TEST_MODE', 'false').lower() == 'true'
    IMAGE_WIDTH = 900
    IMAGE_HEIGHT = 750


class Colors:
    PRIMARY = (0.10, 0.46, 0.82)
    SECONDARY = (0.83, 0.18, 0.18)
    TERTIARY = (0.30, 0.69, 0.31)
    
    POINT_COLORS = [
        (1.00, 0.34, 0.13), (0.30, 0.69, 0.31), (0.13, 0.59, 0.95),
        (0.61, 0.15, 0.69), (0.00, 0.74, 0.83), (1.00, 0.76, 0.03),
    ]
    
    PIE_COLORS = [
        ((0.90, 0.22, 0.20), (0.62, 0.14, 0.12)),
        ((0.18, 0.75, 0.93), (0.10, 0.50, 0.65)),
        ((0.55, 0.85, 0.22), (0.36, 0.58, 0.12)),
        ((0.95, 0.75, 0.12), (0.70, 0.52, 0.06)),
        ((0.68, 0.35, 0.85), (0.45, 0.22, 0.58)),
        ((0.95, 0.52, 0.22), (0.68, 0.35, 0.12)),
    ]
    
    BAR_COLORS = [(0.16, 0.50, 0.73), (0.20, 0.60, 0.86), (0.36, 0.68, 0.89)]
    FILL_LIGHT = (0.13, 0.59, 0.95, 0.15)
    WHITE = (1, 1, 1)
    GRID_DARK = (0.22, 0.25, 0.29)
    GRID_LIGHT = (0.85, 0.85, 0.85)
    HEIGHT_COLOR = (0.83, 0.18, 0.18)
    MEDIAN_COLOR = (0.61, 0.15, 0.69)
    BISECTOR_COLOR = (0.30, 0.69, 0.31)
    
    @classmethod
    def get_point_color(cls, i): return cls.POINT_COLORS[i % len(cls.POINT_COLORS)]
    @classmethod
    def get_pie_colors(cls, i): return cls.PIE_COLORS[i % len(cls.PIE_COLORS)]
    @classmethod
    def get_bar_color(cls, i): return cls.BAR_COLORS[i % len(cls.BAR_COLORS)]


class CairoRenderer:
    def __init__(self, width=900, height=750):
        self.width = width
        self.height = height
        self.surface = None
        self.ctx = None
        self.scale = 50
        self.origin = (width // 2, height // 2)
        self.points = {}
    
    def setup(self, bounds=None, padding=80):
        self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height)
        self.ctx = cairo.Context(self.surface)
        self.ctx.set_antialias(cairo.ANTIALIAS_BEST)
        self.ctx.set_source_rgb(*Colors.WHITE)
        self.ctx.paint()
        if bounds:
            x_min, x_max = bounds.get('x_min', -10), bounds.get('x_max', 10)
            y_min, y_max = bounds.get('y_min', -10), bounds.get('y_max', 10)
            self.scale = min((self.width - 2*padding) / max(x_max - x_min, 0.1),
                           (self.height - 2*padding) / max(y_max - y_min, 0.1))
            self.origin = (self.width/2 - (x_min + x_max)/2 * self.scale,
                          self.height/2 + (y_min + y_max)/2 * self.scale)
    
    def to_px(self, x, y):
        return (self.origin[0] + x * self.scale, self.origin[1] - y * self.scale)
    
    def add_point(self, name, x, y):
        self.points[name] = (x, y)
    
    def draw_line(self, p1, p2, color=None, width=2.5):
        color = color or Colors.PRIMARY
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.set_line_width(width)
        self.ctx.set_line_cap(cairo.LINE_CAP_ROUND)
        px1, py1 = self.to_px(*p1)
        px2, py2 = self.to_px(*p2)
        self.ctx.move_to(px1, py1)
        self.ctx.line_to(px2, py2)
        self.ctx.stroke()
    
    def draw_polygon(self, points, fill_color=None, stroke_color=None, stroke_width=3):
        if not points: return
        px, py = self.to_px(*points[0])
        self.ctx.move_to(px, py)
        for p in points[1:]:
            px, py = self.to_px(*p)
            self.ctx.line_to(px, py)
        self.ctx.close_path()
        if fill_color:
            if len(fill_color) == 4: self.ctx.set_source_rgba(*fill_color)
            else: self.ctx.set_source_rgb(*fill_color)
            if stroke_color: self.ctx.fill_preserve()
            else: self.ctx.fill()
        if stroke_color:
            self.ctx.set_source_rgb(*stroke_color[:3])
            self.ctx.set_line_width(stroke_width)
            self.ctx.set_line_join(cairo.LINE_JOIN_ROUND)
            self.ctx.stroke()
    
    def draw_circle(self, center, radius, fill_color=None, stroke_color=None, stroke_width=3):
        cx, cy = self.to_px(*center)
        self.ctx.arc(cx, cy, radius * self.scale, 0, 2 * math.pi)
        if fill_color:
            if len(fill_color) == 4: self.ctx.set_source_rgba(*fill_color)
            else: self.ctx.set_source_rgb(*fill_color)
            if stroke_color: self.ctx.fill_preserve()
            else: self.ctx.fill()
        if stroke_color:
            self.ctx.set_source_rgb(*stroke_color[:3])
            self.ctx.set_line_width(stroke_width)
            self.ctx.stroke()
    
    def draw_point(self, pos, color, radius=10):
        px, py = self.to_px(*pos)
        self.ctx.set_source_rgba(0, 0, 0, 0.25)
        self.ctx.arc(px + 2, py + 2, radius, 0, 2 * math.pi)
        self.ctx.fill()
        self.ctx.set_source_rgb(*Colors.WHITE)
        self.ctx.arc(px, py, radius + 2, 0, 2 * math.pi)
        self.ctx.fill()
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.arc(px, py, radius, 0, 2 * math.pi)
        self.ctx.fill()
    
    def draw_point_label(self, pos, name, color, position='auto', font_size=20):
        px, py = self.to_px(*pos)
        offsets = {'top': (0,-28), 'bottom': (0,32), 'left': (-28,0), 'right': (28,0),
                   'top_left': (-22,-22), 'top_right': (22,-22), 'bottom_left': (-22,26), 'bottom_right': (22,26)}
        if position == 'auto':
            position = 'top_right' if px > self.origin[0] else 'top_left'
        dx, dy = offsets.get(position, (0,-28))
        self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
        self.ctx.set_font_size(font_size)
        self.ctx.set_source_rgb(*color[:3])
        ext = self.ctx.text_extents(name)
        self.ctx.move_to(px + dx - ext.width/2, py + dy + ext.height/2)
        self.ctx.show_text(name)
    
    def draw_label(self, pos, text, color=None, font_size=16, offset=(0,0)):
        color = color or Colors.PRIMARY
        px, py = self.to_px(*pos)
        px += offset[0]
        py += offset[1]
        self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
        self.ctx.set_font_size(font_size)
        ext = self.ctx.text_extents(text)
        pad = 8
        self._rounded_rect(px - ext.width/2 - pad, py - ext.height/2 - pad, ext.width + 2*pad, ext.height + 2*pad, 5)
        self.ctx.set_source_rgb(*Colors.WHITE)
        self.ctx.fill()
        self._rounded_rect(px - ext.width/2 - pad, py - ext.height/2 - pad, ext.width + 2*pad, ext.height + 2*pad, 5)
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.set_line_width(2)
        self.ctx.stroke()
        self.ctx.move_to(px - ext.width/2, py + ext.height/2 - 2)
        self.ctx.show_text(text)
    
    def _rounded_rect(self, x, y, w, h, r):
        r = min(r, w/2, h/2)
        self.ctx.new_path()
        self.ctx.arc(x+r, y+r, r, math.pi, 1.5*math.pi)
        self.ctx.arc(x+w-r, y+r, r, 1.5*math.pi, 2*math.pi)
        self.ctx.arc(x+w-r, y+h-r, r, 0, 0.5*math.pi)
        self.ctx.arc(x+r, y+h-r, r, 0.5*math.pi, math.pi)
        self.ctx.close_path()
    
    def draw_right_angle(self, vertex, p1, p2, size=0.5, color=None):
        color = color or Colors.SECONDARY
        v = np.array(vertex)
        v1 = np.array(p1) - v
        v2 = np.array(p2) - v
        len1, len2 = np.linalg.norm(v1), np.linalg.norm(v2)
        if len1 < 0.001 or len2 < 0.001: return
        v1, v2 = v1/len1*size, v2/len2*size
        c1, c2, cm = v + v1, v + v2, v + v1 + v2
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.set_line_width(2)
        px1, py1 = self.to_px(*c1)
        px2, py2 = self.to_px(*cm)
        px3, py3 = self.to_px(*c2)
        self.ctx.move_to(px1, py1)
        self.ctx.line_to(px2, py2)
        self.ctx.line_to(px3, py3)
        self.ctx.stroke()
    
    def draw_angle_arc(self, vertex, p1, p2, radius=0.6, color=None, label=None, fill=False):
        color = color or Colors.SECONDARY
        v1 = np.array(p1) - np.array(vertex)
        v2 = np.array(p2) - np.array(vertex)
        a1 = math.atan2(v1[1], v1[0])
        a2 = math.atan2(v2[1], v2[0])
        if a2 - a1 > math.pi: a1 += 2*math.pi
        elif a1 - a2 > math.pi: a2 += 2*math.pi
        if a1 > a2: a1, a2 = a2, a1
        vx, vy = self.to_px(*vertex)
        r_px = radius * self.scale
        if fill:
            self.ctx.move_to(vx, vy)
            self.ctx.arc(vx, vy, r_px, -a2, -a1)
            self.ctx.close_path()
            self.ctx.set_source_rgba(*color[:3], 0.2)
            self.ctx.fill()
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.set_line_width(2)
        self.ctx.arc(vx, vy, r_px, -a2, -a1)
        self.ctx.stroke()
        if label:
            mid = (a1 + a2) / 2
            lx = vertex[0] + radius*1.8*math.cos(mid)
            ly = vertex[1] + radius*1.8*math.sin(mid)
            self.draw_label((lx, ly), label, color, font_size=14)
    
    def draw_altitude(self, triangle, from_vertex, color=None, label=None):
        color = color or Colors.HEIGHT_COLOR
        v = triangle[from_vertex]
        others = [triangle[i] for i in range(3) if i != from_vertex]
        edge = np.array(others[1]) - np.array(others[0])
        edge_len = np.linalg.norm(edge)
        if edge_len < 0.001: return None
        edge_unit = edge / edge_len
        proj = np.dot(np.array(v) - np.array(others[0]), edge_unit)
        foot = np.array(others[0]) + proj * edge_unit
        self.draw_line(v, tuple(foot), color, width=2.5)
        self.draw_right_angle(tuple(foot), v, others[1], size=0.4, color=color)
        self.draw_point(tuple(foot), color, radius=6)
        if label:
            mid = ((v[0] + foot[0])/2, (v[1] + foot[1])/2)
            self.draw_label(mid, label, color, offset=(22, 0))
        return tuple(foot)
    
    def draw_median(self, triangle, from_vertex, color=None, label=None):
        color = color or Colors.MEDIAN_COLOR
        v = triangle[from_vertex]
        others = [triangle[i] for i in range(3) if i != from_vertex]
        mid = ((others[0][0] + others[1][0])/2, (others[0][1] + others[1][1])/2)
        self.draw_line(v, mid, color, width=2.5)
        self.draw_point(mid, color, radius=6)
        if label:
            lp = ((v[0] + mid[0])/2, (v[1] + mid[1])/2)
            self.draw_label(lp, label, color, offset=(22, 0))
        return mid
    
    def draw_angle_bisector(self, triangle, from_vertex, color=None, label=None):
        color = color or Colors.BISECTOR_COLOR
        v = np.array(triangle[from_vertex])
        others = [np.array(triangle[i]) for i in range(3) if i != from_vertex]
        d1 = others[0] - v
        d2 = others[1] - v
        d1 = d1 / np.linalg.norm(d1)
        d2 = d2 / np.linalg.norm(d2)
        bisector = d1 + d2
        bisector = bisector / np.linalg.norm(bisector)
        edge = others[1] - others[0]
        denom = bisector[0]*edge[1] - bisector[1]*edge[0]
        if abs(denom) > 1e-10:
            diff = others[0] - v
            t = (diff[0]*edge[1] - diff[1]*edge[0]) / denom
            end = v + t * bisector
        else:
            end = v + bisector * 5
        self.draw_line(tuple(v), tuple(end), color, width=2.5)
        if label:
            mid = ((v[0] + end[0])/2, (v[1] + end[1])/2)
            self.draw_label(mid, label, color, offset=(22, 0))
        return tuple(end)
    
    def get_png_bytes(self):
        buf = io.BytesIO()
        self.surface.write_to_png(buf)
        return buf.getvalue()
    
    # ═══════════════════════════════════════════════════════════════
    # EK ÖZELLİKLER - Koordinat Düzlemi, Çember Açıları, Merkezler
    # ═══════════════════════════════════════════════════════════════
    
    def draw_grid(self, x_range, y_range, show_axes=True, show_numbers=True):
        """Koordinat düzlemi çiz"""
        x_min, x_max = x_range
        y_min, y_max = y_range
        self.ctx.set_source_rgb(*Colors.GRID_LIGHT)
        self.ctx.set_line_width(0.5)
        for x in range(x_min, x_max + 1):
            px1, py1 = self.to_px(x, y_min)
            px2, py2 = self.to_px(x, y_max)
            self.ctx.move_to(px1, py1)
            self.ctx.line_to(px2, py2)
            self.ctx.stroke()
        for y in range(y_min, y_max + 1):
            px1, py1 = self.to_px(x_min, y)
            px2, py2 = self.to_px(x_max, y)
            self.ctx.move_to(px1, py1)
            self.ctx.line_to(px2, py2)
            self.ctx.stroke()
        if show_axes:
            self.ctx.set_source_rgb(*Colors.GRID_DARK)
            self.ctx.set_line_width(2)
            if y_min <= 0 <= y_max:
                px1, py1 = self.to_px(x_min, 0)
                px2, py2 = self.to_px(x_max, 0)
                self.ctx.move_to(px1, py1)
                self.ctx.line_to(px2, py2)
                self.ctx.stroke()
            if x_min <= 0 <= x_max:
                px1, py1 = self.to_px(0, y_min)
                px2, py2 = self.to_px(0, y_max)
                self.ctx.move_to(px1, py1)
                self.ctx.line_to(px2, py2)
                self.ctx.stroke()
        if show_numbers:
            self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            self.ctx.set_font_size(11)
            self.ctx.set_source_rgb(*Colors.GRID_DARK)
            for x in range(x_min, x_max + 1):
                if x != 0 and y_min <= 0 <= y_max:
                    px, py = self.to_px(x, 0)
                    self.ctx.move_to(px - 4, py + 18)
                    self.ctx.show_text(str(x))
            for y in range(y_min, y_max + 1):
                if y != 0 and x_min <= 0 <= x_max:
                    px, py = self.to_px(0, y)
                    self.ctx.move_to(px - 20, py + 4)
                    self.ctx.show_text(str(y))
    
    def draw_arc(self, center, radius, start_deg, end_deg, color=None, width=3):
        """Yay çiz"""
        color = color or Colors.PRIMARY
        cx, cy = self.to_px(*center)
        r_px = radius * self.scale
        self.ctx.arc(cx, cy, r_px, -math.radians(end_deg), -math.radians(start_deg))
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.set_line_width(width)
        self.ctx.stroke()
    
    def draw_sector(self, center, radius, start_deg, end_deg, fill_color=None, stroke_color=None, label=None):
        """Daire dilimi çiz"""
        fill_color = fill_color or (1.0, 0.76, 0.03, 0.4)
        stroke_color = stroke_color or Colors.PRIMARY
        cx, cy = self.to_px(*center)
        r_px = radius * self.scale
        self.ctx.move_to(cx, cy)
        self.ctx.arc(cx, cy, r_px, -math.radians(end_deg), -math.radians(start_deg))
        self.ctx.close_path()
        if len(fill_color) == 4:
            self.ctx.set_source_rgba(*fill_color)
        else:
            self.ctx.set_source_rgb(*fill_color)
        self.ctx.fill_preserve()
        self.ctx.set_source_rgb(*stroke_color[:3])
        self.ctx.set_line_width(2)
        self.ctx.stroke()
        if label:
            mid_deg = (start_deg + end_deg) / 2
            lx = center[0] + radius * 0.6 * math.cos(math.radians(mid_deg))
            ly = center[1] + radius * 0.6 * math.sin(math.radians(mid_deg))
            self.draw_label((lx, ly), label, stroke_color, font_size=14)
    
    def draw_ray(self, start, through, color=None, width=2.5, length=50):
        """Işın çiz (tek yönde sonsuz)"""
        color = color or Colors.PRIMARY
        dx = through[0] - start[0]
        dy = through[1] - start[1]
        dist = math.sqrt(dx*dx + dy*dy)
        if dist < 0.001: return
        dx, dy = dx / dist, dy / dist
        end = (start[0] + dx * length, start[1] + dy * length)
        self.draw_line(start, end, color, width)
        self._draw_arrow(end, math.atan2(dy, dx), color)
    
    def draw_full_line(self, p1, p2, color=None, width=2.5, length=50):
        """Doğru çiz (iki yönde sonsuz)"""
        color = color or Colors.PRIMARY
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        dist = math.sqrt(dx*dx + dy*dy)
        if dist < 0.001: return
        dx, dy = dx / dist, dy / dist
        start = (p1[0] - dx * length, p1[1] - dy * length)
        end = (p2[0] + dx * length, p2[1] + dy * length)
        self.draw_line(start, end, color, width)
        self._draw_arrow(end, math.atan2(dy, dx), color)
        self._draw_arrow(start, math.atan2(-dy, -dx), color)
    
    def _draw_arrow(self, tip, angle, color, size=10):
        """Ok ucu çiz"""
        px, py = self.to_px(*tip)
        angle = -angle
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.set_line_width(2)
        for delta in [0.4, -0.4]:
            a = angle + math.pi + delta
            self.ctx.move_to(px, py)
            self.ctx.line_to(px + size * math.cos(a), py + size * math.sin(a))
            self.ctx.stroke()
    
    # ─────────────────────────────────────────────────────────────────
    # ÜÇGEN MERKEZLERİ
    # ─────────────────────────────────────────────────────────────────
    
    def calc_centroid(self, points):
        """Ağırlık merkezi (G)"""
        return (sum(p[0] for p in points) / len(points), sum(p[1] for p in points) / len(points))
    
    def calc_incenter(self, triangle):
        """İç teğet merkezi (I)"""
        A, B, C = [np.array(p) for p in triangle]
        a, b, c = np.linalg.norm(B - C), np.linalg.norm(A - C), np.linalg.norm(A - B)
        return tuple((a * A + b * B + c * C) / (a + b + c))
    
    def calc_circumcenter(self, triangle):
        """Çevrel merkez (O)"""
        A, B, C = [np.array(p) for p in triangle]
        D = 2 * (A[0]*(B[1]-C[1]) + B[0]*(C[1]-A[1]) + C[0]*(A[1]-B[1]))
        if abs(D) < 1e-10: return self.calc_centroid(triangle)
        ux = ((A[0]**2+A[1]**2)*(B[1]-C[1]) + (B[0]**2+B[1]**2)*(C[1]-A[1]) + (C[0]**2+C[1]**2)*(A[1]-B[1])) / D
        uy = ((A[0]**2+A[1]**2)*(C[0]-B[0]) + (B[0]**2+B[1]**2)*(A[0]-C[0]) + (C[0]**2+C[1]**2)*(B[0]-A[0])) / D
        return (ux, uy)
    
    def calc_orthocenter(self, triangle):
        """Diklik merkezi (H)"""
        A, B, C = [np.array(p) for p in triangle]
        O = np.array(self.calc_circumcenter(triangle))
        return tuple(A + B + C - 2 * O)
    
    def calc_inradius(self, triangle):
        """İç teğet çember yarıçapı"""
        A, B, C = [np.array(p) for p in triangle]
        a, b, c = np.linalg.norm(B - C), np.linalg.norm(A - C), np.linalg.norm(A - B)
        s = (a + b + c) / 2
        area = math.sqrt(s * (s - a) * (s - b) * (s - c))
        return area / s
    
    def calc_circumradius(self, triangle):
        """Çevrel çember yarıçapı"""
        A, B, C = [np.array(p) for p in triangle]
        a, b, c = np.linalg.norm(B - C), np.linalg.norm(A - C), np.linalg.norm(A - B)
        s = (a + b + c) / 2
        area = math.sqrt(s * (s - a) * (s - b) * (s - c))
        if area < 1e-10: return 0
        return (a * b * c) / (4 * area)
    
    def draw_inscribed_circle(self, triangle, color=None):
        """Üçgenin iç teğet çemberini çiz"""
        color = color or (0.13, 0.59, 0.95)
        center = self.calc_incenter(triangle)
        radius = self.calc_inradius(triangle)
        self.draw_circle(center, radius, (*color, 0.1), color, stroke_width=2)
        self.draw_point(center, color, radius=6)
    
    def draw_circumscribed_circle(self, triangle, color=None):
        """Üçgenin çevrel çemberini çiz"""
        color = color or (0.61, 0.15, 0.69)
        center = self.calc_circumcenter(triangle)
        radius = self.calc_circumradius(triangle)
        self.draw_circle(center, radius, (*color, 0.1), color, stroke_width=2)
        self.draw_point(center, color, radius=6)
    
    # ─────────────────────────────────────────────────────────────────
    # ÇEMBER AÇILARI
    # ─────────────────────────────────────────────────────────────────
    
    def draw_central_angle(self, center, radius, angle1, angle2, color=None, label=None):
        """Merkez açı çiz"""
        color = color or Colors.SECONDARY
        p1 = (center[0] + radius * math.cos(math.radians(angle1)),
              center[1] + radius * math.sin(math.radians(angle1)))
        p2 = (center[0] + radius * math.cos(math.radians(angle2)),
              center[1] + radius * math.sin(math.radians(angle2)))
        self.draw_line(center, p1, color, width=2)
        self.draw_line(center, p2, color, width=2)
        self.draw_angle_arc(center, p1, p2, radius=0.8, color=color, label=label, fill=True)
        self.draw_arc(center, radius, angle1, angle2, (1.0, 0.76, 0.03), width=4)
        return p1, p2
    
    def draw_inscribed_angle(self, center, radius, vertex_angle, arc_start, arc_end, color=None, label=None):
        """Çevre açı çiz"""
        color = color or Colors.TERTIARY
        vertex = (center[0] + radius * math.cos(math.radians(vertex_angle)),
                  center[1] + radius * math.sin(math.radians(vertex_angle)))
        p1 = (center[0] + radius * math.cos(math.radians(arc_start)),
              center[1] + radius * math.sin(math.radians(arc_start)))
        p2 = (center[0] + radius * math.cos(math.radians(arc_end)),
              center[1] + radius * math.sin(math.radians(arc_end)))
        self.draw_line(vertex, p1, color, width=2)
        self.draw_line(vertex, p2, color, width=2)
        self.draw_angle_arc(vertex, p1, p2, radius=0.5, color=color, label=label, fill=True)
        return vertex, p1, p2
    
    def draw_tangent_line(self, center, radius, angle, length=5, color=None):
        """Teğet çizgisi çiz"""
        color = color or Colors.SECONDARY
        touch = (center[0] + radius * math.cos(math.radians(angle)),
                 center[1] + radius * math.sin(math.radians(angle)))
        tangent_angle = angle + 90
        dx = math.cos(math.radians(tangent_angle))
        dy = math.sin(math.radians(tangent_angle))
        p1 = (touch[0] - dx * length / 2, touch[1] - dy * length / 2)
        p2 = (touch[0] + dx * length / 2, touch[1] + dy * length / 2)
        self.draw_line(p1, p2, color, width=2)
        self.draw_point(touch, color, radius=6)
        radius_end = (touch[0] + 0.5 * math.cos(math.radians(angle + 180)),
                      touch[1] + 0.5 * math.sin(math.radians(angle + 180)))
        self.draw_right_angle(touch, radius_end, p2, size=0.3, color=color)
        return touch, p1, p2
    
    # ─────────────────────────────────────────────────────────────────
    # DÜZGÜN ÇOKGENLER VE ÖZEL DÖRTGENLER
    # ─────────────────────────────────────────────────────────────────
    
    def create_regular_polygon(self, center, radius, n, rotation=-90):
        """Düzgün n-gen köşelerini hesapla"""
        return [(center[0] + radius * math.cos(math.radians(rotation + i * 360 / n)),
                 center[1] + radius * math.sin(math.radians(rotation + i * 360 / n)))
                for i in range(n)]
    
    def create_square(self, center, side, rotation=0):
        """Kare köşelerini hesapla"""
        return self.create_regular_polygon(center, side / math.sqrt(2), 4, rotation + 45)
    
    def create_rectangle(self, center, width, height, rotation=0):
        """Dikdörtgen köşelerini hesapla"""
        hw, hh = width / 2, height / 2
        corners = [(-hw, -hh), (hw, -hh), (hw, hh), (-hw, hh)]
        rad = math.radians(rotation)
        cos_r, sin_r = math.cos(rad), math.sin(rad)
        return [(center[0] + c[0]*cos_r - c[1]*sin_r, center[1] + c[0]*sin_r + c[1]*cos_r) for c in corners]
    
    def create_parallelogram(self, base_start, base_end, height, slant=0):
        """Paralelkenar köşelerini hesapla"""
        A, B = base_start, base_end
        base_vec = (B[0] - A[0], B[1] - A[1])
        base_len = math.sqrt(base_vec[0]**2 + base_vec[1]**2)
        perp = (-base_vec[1] / base_len, base_vec[0] / base_len)
        slant_vec = (base_vec[0] / base_len * slant, base_vec[1] / base_len * slant)
        D = (A[0] + perp[0]*height + slant_vec[0], A[1] + perp[1]*height + slant_vec[1])
        C = (B[0] + perp[0]*height + slant_vec[0], B[1] + perp[1]*height + slant_vec[1])
        return [A, B, C, D]
    
    def create_trapezoid(self, base_start, base_end, top_width, height):
        """Yamuk köşelerini hesapla"""
        A, B = base_start, base_end
        base_vec = (B[0] - A[0], B[1] - A[1])
        base_len = math.sqrt(base_vec[0]**2 + base_vec[1]**2)
        perp = (-base_vec[1] / base_len, base_vec[0] / base_len)
        base_unit = (base_vec[0] / base_len, base_vec[1] / base_len)
        offset = (base_len - top_width) / 2
        D = (A[0] + perp[0]*height + base_unit[0]*offset, A[1] + perp[1]*height + base_unit[1]*offset)
        C = (D[0] + base_unit[0]*top_width, D[1] + base_unit[1]*top_width)
        return [A, B, C, D]
    
    def create_rhombus(self, center, d1, d2, rotation=0):
        """Eşkenar dörtgen köşelerini hesapla"""
        rad = math.radians(rotation)
        cos_r, sin_r = math.cos(rad), math.sin(rad)
        pts = [(d1/2, 0), (0, d2/2), (-d1/2, 0), (0, -d2/2)]
        return [(center[0] + p[0]*cos_r - p[1]*sin_r, center[1] + p[0]*sin_r + p[1]*cos_r) for p in pts]
    
    # ─────────────────────────────────────────────────────────────────
    # KOORDİNAT ETİKETLERİ
    # ─────────────────────────────────────────────────────────────────
    
    def draw_point_with_coords(self, pos, name, color, position='auto', font_size=18):
        """Koordinatlı nokta etiketi: A(1,1) formatı"""
        self.draw_point(pos, color)
        label = f"{name}({pos[0]},{pos[1]})"
        px, py = self.to_px(*pos)
        offsets = {'top': (0,-30), 'bottom': (0,35), 'left': (-50,0), 'right': (50,0),
                   'top_left': (-40,-25), 'top_right': (40,-25),
                   'bottom_left': (-40,30), 'bottom_right': (40,30)}
        if position == 'auto':
            position = 'bottom_right' if px < self.origin[0] else 'bottom_left'
        dx, dy = offsets.get(position, (0, 35))
        self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
        self.ctx.set_font_size(font_size)
        self.ctx.set_source_rgb(*color[:3])
        ext = self.ctx.text_extents(label)
        self.ctx.move_to(px + dx - ext.width/2, py + dy + ext.height/2)
        self.ctx.show_text(label)
    
    # ─────────────────────────────────────────────────────────────────
    # KENAR ORTA DİKMESİ
    # ─────────────────────────────────────────────────────────────────
    
    def draw_perpendicular_bisector(self, p1, p2, color=None, label=None, length=3):
        """Kenar orta dikmesi çiz"""
        color = color or (0.00, 0.74, 0.83)
        mid = ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2)
        dx, dy = p2[0] - p1[0], p2[1] - p1[1]
        seg_len = math.sqrt(dx*dx + dy*dy)
        if seg_len < 0.001: return mid
        perp = (-dy / seg_len, dx / seg_len)
        start = (mid[0] - perp[0] * length / 2, mid[1] - perp[1] * length / 2)
        end = (mid[0] + perp[0] * length / 2, mid[1] + perp[1] * length / 2)
        self.draw_line(start, end, color, width=2)
        self.draw_right_angle(mid, p1, end, size=0.3, color=color)
        self.draw_point(mid, color, radius=5)
        if label:
            self.draw_label(mid, label, color, offset=(20, -15))
        return mid
    
    # ─────────────────────────────────────────────────────────────────
    # PARALEL DOĞRULAR VE AÇI KURALLARI
    # ─────────────────────────────────────────────────────────────────
    
    def draw_parallel_lines(self, y1, y2, x_range=(-5, 5), color=None):
        """İki paralel yatay doğru çiz"""
        color = color or Colors.PRIMARY
        self.draw_line((x_range[0], y1), (x_range[1], y1), color, width=2.5)
        self.draw_line((x_range[0], y2), (x_range[1], y2), color, width=2.5)
        mid_x = (x_range[0] + x_range[1]) / 2
        self._draw_parallel_marks((mid_x - 1, y1), 0, color)
        self._draw_parallel_marks((mid_x - 1, y2), 0, color)
    
    def _draw_parallel_marks(self, pos, angle, color, size=0.3):
        """Paralel işareti (>>)"""
        px, py = self.to_px(*pos)
        self.ctx.set_source_rgb(*color[:3])
        self.ctx.set_line_width(2)
        for offset in [-5, 5]:
            self.ctx.move_to(px + offset - size*self.scale*0.3, py - size*self.scale*0.2)
            self.ctx.line_to(px + offset, py)
            self.ctx.line_to(px + offset - size*self.scale*0.3, py + size*self.scale*0.2)
            self.ctx.stroke()
    
    def draw_transversal(self, p1, p2, color=None):
        """Kesen doğru çiz"""
        color = color or Colors.SECONDARY
        self.draw_line(p1, p2, color, width=2.5)
    
    def draw_m_rule_angles(self, intersection1, intersection2, angle_size=0.5):
        """M Kuralı - Yöndeş açılar"""
        color = (1.0, 0.76, 0.03)
        self.draw_sector(intersection1, angle_size, 0, 45, (*color, 0.4), color, "α")
        self.draw_sector(intersection2, angle_size, 0, 45, (*color, 0.4), color, "α")
    
    def draw_z_rule_angles(self, intersection1, intersection2, angle_size=0.5):
        """Z Kuralı - Ters açılar"""
        color = (0.30, 0.69, 0.31)
        self.draw_sector(intersection1, angle_size, 0, 45, (*color, 0.4), color, "β")
        self.draw_sector(intersection2, angle_size, 180, 225, (*color, 0.4), color, "β")
    
    def draw_u_rule_angles(self, intersection1, intersection2, angle_size=0.5):
        """U Kuralı - İç ters açılar"""
        color1 = (0.83, 0.18, 0.18)
        color2 = (0.13, 0.59, 0.95)
        self.draw_sector(intersection1, angle_size, 135, 180, (*color1, 0.4), color1, "γ")
        self.draw_sector(intersection2, angle_size, 0, 45, (*color2, 0.4), color2, "δ")
    
    # ─────────────────────────────────────────────────────────────────
    # İÇ İÇE ŞEKİLLER (NESTED)
    # ─────────────────────────────────────────────────────────────────
    
    def draw_inscribed_polygon(self, center, radius, n, rotation=-90, fill_color=None, stroke_color=None):
        """Çembere içten teğet düzgün çokgen"""
        fill_color = fill_color or Colors.FILL_LIGHT
        stroke_color = stroke_color or Colors.PRIMARY
        points = self.create_regular_polygon(center, radius, n, rotation)
        self.draw_polygon(points, fill_color, stroke_color)
        return points
    
    def draw_circumscribed_polygon(self, center, radius, n, rotation=-90, fill_color=None, stroke_color=None):
        """Çembere dıştan teğet düzgün çokgen"""
        fill_color = fill_color or Colors.FILL_LIGHT
        stroke_color = stroke_color or Colors.ACCENT
        outer_radius = radius / math.cos(math.pi / n)
        points = self.create_regular_polygon(center, outer_radius, n, rotation)
        self.draw_polygon(points, fill_color, stroke_color)
        return points
    
    def draw_triangle_with_circles(self, triangle, show_incircle=True, show_circumcircle=True):
        """Üçgen + iç teğet + çevrel çember"""
        self.draw_polygon(triangle, Colors.FILL_LIGHT, Colors.PRIMARY, stroke_width=3)
        if show_circumcircle:
            self.draw_circumscribed_circle(triangle, (0.30, 0.69, 0.31))
        if show_incircle:
            self.draw_inscribed_circle(triangle, (0.83, 0.18, 0.18))
        for i, p in enumerate(triangle):
            self.draw_point(p, Colors.get_point_color(i))


# ═══════════════════════════════════════════════════════════════
# 3D KÜPÜ (Matplotlib ile)
# ═══════════════════════════════════════════════════════════════

class Cube3DRenderer:
    """3D Küp çizici - Matplotlib ile"""
    
    def __init__(self, width=900, height=750):
        self.width = width
        self.height = height
        self.dpi = 100
        self.fig = None
        self.ax = None
    
    def setup(self, elev=20, azim=45):
        """3D sahne kur"""
        try:
            import matplotlib
            matplotlib.use('Agg')
            import matplotlib.pyplot as plt
            from mpl_toolkits.mplot3d import Axes3D
            from mpl_toolkits.mplot3d.art3d import Poly3DCollection
            
            self.plt = plt
            self.Poly3DCollection = Poly3DCollection
            
            self.fig = plt.figure(figsize=(self.width/self.dpi, self.height/self.dpi), dpi=self.dpi)
            self.ax = self.fig.add_subplot(111, projection='3d')
            self.ax.view_init(elev=elev, azim=azim)
            self.ax.set_box_aspect([1, 1, 1])
            return True
        except ImportError:
            logger.warning("Matplotlib 3D mevcut değil")
            return False
    
    def draw_cube(self, size=4, origin=(0, 0, 0), color='#3498db', alpha=0.8, edge_label=None):
        """Küp çiz"""
        if not self.ax:
            return
        
        ox, oy, oz = origin
        s = size
        
        vertices = [
            [ox, oy, oz], [ox+s, oy, oz], [ox+s, oy+s, oz], [ox, oy+s, oz],
            [ox, oy, oz+s], [ox+s, oy, oz+s], [ox+s, oy+s, oz+s], [ox, oy+s, oz+s]
        ]
        
        faces = [
            [vertices[0], vertices[1], vertices[2], vertices[3]],
            [vertices[4], vertices[5], vertices[6], vertices[7]],
            [vertices[0], vertices[1], vertices[5], vertices[4]],
            [vertices[2], vertices[3], vertices[7], vertices[6]],
            [vertices[0], vertices[3], vertices[7], vertices[4]],
            [vertices[1], vertices[2], vertices[6], vertices[5]]
        ]
        
        self.ax.add_collection3d(self.Poly3DCollection(
            faces, facecolors=color, linewidths=1, edgecolors='#2c3e50', alpha=alpha
        ))
        
        labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
        point_colors = [Colors.get_point_color(i) for i in range(8)]
        
        for i, (v, lbl) in enumerate(zip(vertices, labels)):
            self.ax.scatter(*v, color=point_colors[i], s=80, depthshade=False)
            self.ax.text(v[0], v[1], v[2] + 0.3, lbl, fontsize=12, fontweight='bold',
                        color=point_colors[i], ha='center')
        
        if edge_label:
            mid = [(vertices[0][i] + vertices[1][i]) / 2 for i in range(3)]
            self.ax.text(mid[0], mid[1] - 0.5, mid[2], edge_label,
                        fontsize=11, bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        
        margin = s * 0.3
        self.ax.set_xlim([ox - margin, ox + s + margin])
        self.ax.set_ylim([oy - margin, oy + s + margin])
        self.ax.set_zlim([oz - margin, oz + s + margin])
        
        self.ax.set_xlabel('')
        self.ax.set_ylabel('')
        self.ax.set_zlabel('')
        self.ax.set_xticks([])
        self.ax.set_yticks([])
        self.ax.set_zticks([])
        
        for spine in self.ax.spines.values():
            spine.set_visible(False)
        self.ax.xaxis.pane.fill = False
        self.ax.yaxis.pane.fill = False
        self.ax.zaxis.pane.fill = False
    
    def draw_rectangular_prism(self, width, height, depth, origin=(0, 0, 0), color='#3498db'):
        """Dikdörtgenler prizması"""
        if not self.ax:
            return
        
        ox, oy, oz = origin
        w, h, d = width, height, depth
        
        vertices = [
            [ox, oy, oz], [ox+w, oy, oz], [ox+w, oy+h, oz], [ox, oy+h, oz],
            [ox, oy, oz+d], [ox+w, oy, oz+d], [ox+w, oy+h, oz+d], [ox, oy+h, oz+d]
        ]
        
        faces = [
            [vertices[0], vertices[1], vertices[2], vertices[3]],
            [vertices[4], vertices[5], vertices[6], vertices[7]],
            [vertices[0], vertices[1], vertices[5], vertices[4]],
            [vertices[2], vertices[3], vertices[7], vertices[6]],
            [vertices[0], vertices[3], vertices[7], vertices[4]],
            [vertices[1], vertices[2], vertices[6], vertices[5]]
        ]
        
        self.ax.add_collection3d(self.Poly3DCollection(
            faces, facecolors=color, linewidths=1, edgecolors='#2c3e50', alpha=0.8
        ))
        
        max_dim = max(w, h, d)
        margin = max_dim * 0.3
        self.ax.set_xlim([ox - margin, ox + w + margin])
        self.ax.set_ylim([oy - margin, oy + h + margin])
        self.ax.set_zlim([oz - margin, oz + d + margin])
    
    def get_png_bytes(self):
        """PNG bytes döndür"""
        if not self.fig:
            return None
        buf = io.BytesIO()
        self.fig.savefig(buf, format='png', bbox_inches='tight', facecolor='white')
        buf.seek(0)
        self.plt.close(self.fig)
        return buf.getvalue()
    
    def draw_cylinder(self, radius=2, height=4, origin=(0, 0, 0), color='#3498db', alpha=0.7):
        """Silindir çiz"""
        if not self.ax:
            return
        
        ox, oy, oz = origin
        u = np.linspace(0, 2 * np.pi, 50)
        h = np.linspace(0, height, 2)
        
        # Yan yüzey
        x = ox + radius * np.outer(np.cos(u), np.ones(len(h)))
        y = oy + radius * np.outer(np.sin(u), np.ones(len(h)))
        z = oz + np.outer(np.ones(len(u)), h)
        self.ax.plot_surface(x, y, z, color=color, alpha=alpha, linewidth=0)
        
        # Alt ve üst daireler
        theta = np.linspace(0, 2 * np.pi, 50)
        r = np.linspace(0, radius, 10)
        T, R = np.meshgrid(theta, r)
        X = ox + R * np.cos(T)
        Y = oy + R * np.sin(T)
        
        # Alt daire
        Z_bottom = oz + np.zeros_like(X)
        self.ax.plot_surface(X, Y, Z_bottom, color=color, alpha=alpha)
        
        # Üst daire
        Z_top = oz + height + np.zeros_like(X)
        self.ax.plot_surface(X, Y, Z_top, color=color, alpha=alpha)
        
        # Etiketler
        self.ax.text(ox, oy - radius - 0.5, oz, f'r={radius}', fontsize=10,
                    bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        self.ax.text(ox + radius + 0.3, oy, oz + height/2, f'h={height}', fontsize=10,
                    bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        
        self._set_3d_limits(ox, oy, oz, max(radius*2, height))
    
    def draw_sphere(self, radius=3, origin=(0, 0, 0), color='#3498db', alpha=0.7):
        """Küre çiz"""
        if not self.ax:
            return
        
        ox, oy, oz = origin
        u = np.linspace(0, 2 * np.pi, 50)
        v = np.linspace(0, np.pi, 50)
        
        x = ox + radius * np.outer(np.cos(u), np.sin(v))
        y = oy + radius * np.outer(np.sin(u), np.sin(v))
        z = oz + radius * np.outer(np.ones(np.size(u)), np.cos(v))
        
        self.ax.plot_surface(x, y, z, color=color, alpha=alpha, linewidth=0)
        
        # Yarıçap çizgisi
        self.ax.plot([ox, ox + radius], [oy, oy], [oz, oz], 'k-', linewidth=2)
        self.ax.text(ox + radius/2, oy - 0.3, oz, f'r={radius}', fontsize=10,
                    bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        
        # Merkez noktası
        self.ax.scatter(ox, oy, oz, color='red', s=50)
        self.ax.text(ox, oy, oz + 0.5, 'O', fontsize=12, fontweight='bold', color='red')
        
        self._set_3d_limits(ox, oy, oz, radius * 2)
    
    def draw_cone(self, radius=2, height=4, origin=(0, 0, 0), color='#e74c3c', alpha=0.7):
        """Koni çiz"""
        if not self.ax:
            return
        
        ox, oy, oz = origin
        
        # Yan yüzey
        u = np.linspace(0, 2 * np.pi, 50)
        h = np.linspace(0, height, 50)
        U, H = np.meshgrid(u, h)
        
        # Yarıçap yükseklikle azalır
        R = radius * (1 - H / height)
        X = ox + R * np.cos(U)
        Y = oy + R * np.sin(U)
        Z = oz + H
        
        self.ax.plot_surface(X, Y, Z, color=color, alpha=alpha, linewidth=0)
        
        # Taban dairesi
        theta = np.linspace(0, 2 * np.pi, 50)
        r = np.linspace(0, radius, 10)
        T, R_base = np.meshgrid(theta, r)
        X_base = ox + R_base * np.cos(T)
        Y_base = oy + R_base * np.sin(T)
        Z_base = oz + np.zeros_like(X_base)
        self.ax.plot_surface(X_base, Y_base, Z_base, color=color, alpha=alpha)
        
        # Tepe noktası
        self.ax.scatter(ox, oy, oz + height, color='darkred', s=80)
        self.ax.text(ox, oy, oz + height + 0.3, 'T', fontsize=12, fontweight='bold')
        
        # Etiketler
        self.ax.text(ox, oy - radius - 0.5, oz, f'r={radius}', fontsize=10,
                    bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        self.ax.text(ox + radius + 0.3, oy, oz + height/2, f'h={height}', fontsize=10,
                    bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        
        self._set_3d_limits(ox, oy, oz, max(radius*2, height))
    
    def draw_pyramid(self, base_size=4, height=5, origin=(0, 0, 0), color='#9b59b6', alpha=0.7, n_sides=4):
        """Piramit çiz (kare veya üçgen tabanlı)"""
        if not self.ax:
            return
        
        ox, oy, oz = origin
        s = base_size / 2
        
        # Tepe noktası
        apex = [ox, oy, oz + height]
        
        if n_sides == 4:  # Kare tabanlı
            base = [
                [ox - s, oy - s, oz],
                [ox + s, oy - s, oz],
                [ox + s, oy + s, oz],
                [ox - s, oy + s, oz]
            ]
            labels = ['A', 'B', 'C', 'D']
        else:  # Üçgen tabanlı (tetrahedron)
            base = [
                [ox, oy + s, oz],
                [ox - s * 0.866, oy - s * 0.5, oz],
                [ox + s * 0.866, oy - s * 0.5, oz]
            ]
            labels = ['A', 'B', 'C']
        
        # Taban yüzeyi
        base_face = [base]
        self.ax.add_collection3d(self.Poly3DCollection(
            base_face, facecolors=color, linewidths=1, edgecolors='#2c3e50', alpha=alpha
        ))
        
        # Yan yüzeyler
        for i in range(len(base)):
            face = [base[i], base[(i + 1) % len(base)], apex]
            self.ax.add_collection3d(self.Poly3DCollection(
                [face], facecolors=color, linewidths=1, edgecolors='#2c3e50', alpha=alpha * 0.9
            ))
        
        # Köşe noktaları ve etiketler
        point_colors = [Colors.get_point_color(i) for i in range(len(base) + 1)]
        for i, (v, lbl) in enumerate(zip(base, labels)):
            self.ax.scatter(*v, color=point_colors[i], s=80)
            self.ax.text(v[0], v[1], v[2] - 0.4, lbl, fontsize=12, fontweight='bold',
                        color=point_colors[i], ha='center')
        
        # Tepe
        self.ax.scatter(*apex, color=point_colors[-1], s=80)
        self.ax.text(apex[0], apex[1], apex[2] + 0.3, 'T', fontsize=12, fontweight='bold',
                    color=point_colors[-1], ha='center')
        
        # Yükseklik çizgisi (kesikli)
        self.ax.plot([ox, ox], [oy, oy], [oz, oz + height], 'k--', linewidth=1.5)
        self.ax.text(ox + 0.3, oy, oz + height/2, f'h={height}', fontsize=10,
                    bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        
        self._set_3d_limits(ox, oy, oz, max(base_size, height))
    
    def draw_triangular_prism(self, base_size=3, height=5, origin=(0, 0, 0), color='#1abc9c', alpha=0.7):
        """Üçgen prizma çiz"""
        if not self.ax:
            return
        
        ox, oy, oz = origin
        s = base_size / 2
        h = base_size * 0.866  # Eşkenar üçgen yüksekliği
        
        # Alt üçgen
        base_bottom = [
            [ox, oy + h/2, oz],
            [ox - s, oy - h/2, oz],
            [ox + s, oy - h/2, oz]
        ]
        
        # Üst üçgen
        base_top = [
            [ox, oy + h/2, oz + height],
            [ox - s, oy - h/2, oz + height],
            [ox + s, oy - h/2, oz + height]
        ]
        
        # Yüzeyler
        faces = [
            base_bottom,  # Alt
            base_top,     # Üst
            [base_bottom[0], base_bottom[1], base_top[1], base_top[0]],  # Yan 1
            [base_bottom[1], base_bottom[2], base_top[2], base_top[1]],  # Yan 2
            [base_bottom[2], base_bottom[0], base_top[0], base_top[2]]   # Yan 3
        ]
        
        self.ax.add_collection3d(self.Poly3DCollection(
            faces, facecolors=color, linewidths=1, edgecolors='#2c3e50', alpha=alpha
        ))
        
        # Köşe etiketleri
        labels_bottom = ['A', 'B', 'C']
        labels_top = ['D', 'E', 'F']
        
        for i, (v, lbl) in enumerate(zip(base_bottom, labels_bottom)):
            self.ax.scatter(*v, color=Colors.get_point_color(i), s=60)
            self.ax.text(v[0], v[1], v[2] - 0.3, lbl, fontsize=11, fontweight='bold')
        
        for i, (v, lbl) in enumerate(zip(base_top, labels_top)):
            self.ax.scatter(*v, color=Colors.get_point_color(i + 3), s=60)
            self.ax.text(v[0], v[1], v[2] + 0.3, lbl, fontsize=11, fontweight='bold')
        
        self._set_3d_limits(ox, oy, oz, max(base_size, height))
    
    def _set_3d_limits(self, ox, oy, oz, size):
        """3D görünüm limitlerini ayarla"""
        margin = size * 0.3
        self.ax.set_xlim([ox - size/2 - margin, ox + size/2 + margin])
        self.ax.set_ylim([oy - size/2 - margin, oy + size/2 + margin])
        self.ax.set_zlim([oz - margin, oz + size + margin])
        self.ax.set_xlabel('')
        self.ax.set_ylabel('')
        self.ax.set_zlabel('')
        self.ax.set_xticks([])
        self.ax.set_yticks([])
        self.ax.set_zticks([])
        for spine in self.ax.spines.values():
            spine.set_visible(False)
        self.ax.xaxis.pane.fill = False
        self.ax.yaxis.pane.fill = False
        self.ax.zaxis.pane.fill = False
    def __init__(self, width=700, height=620):
        self.width = width
        self.height = height
        self.surface = None
        self.ctx = None
    
    def setup(self, bg_color=None):
        self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height)
        self.ctx = cairo.Context(self.surface)
        self.ctx.set_antialias(cairo.ANTIALIAS_BEST)
        if bg_color:
            self.ctx.set_source_rgb(*bg_color)
            self.ctx.paint()
    
    def draw(self, values, labels=None, center=None, radius=None, depth=45, gap=8,
             explode=None, start_angle=-90, title=None, value_type='percent', show_legend=True):
        center = center or (self.width // 2, self.height // 2 - 10)
        radius = radius or min(self.width, self.height) * 0.30
        labels = labels or [f"Dilim {i+1}" for i in range(len(values))]
        explode = explode or [0] * len(values)
        total = sum(values)
        if total == 0: return
        
        if title:
            self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
            self.ctx.set_font_size(20)
            self.ctx.set_source_rgb(*Colors.GRID_DARK)
            ext = self.ctx.text_extents(title)
            self.ctx.move_to((self.width - ext.width) / 2, 38)
            self.ctx.show_text(title)
            center = (center[0], center[1] + 15)
        
        slices = []
        current = start_angle
        for i, val in enumerate(values):
            sweep = (val / total) * 360
            slices.append({'index': i, 'start': current, 'sweep': sweep, 'value': val})
            current += sweep
        
        draw_order = sorted(slices, key=lambda s: -math.sin(math.radians(s['start'] + s['sweep']/2)))
        
        for s in slices:
            mid_rad = math.radians(s['start'] + s['sweep'] / 2)
            exp = explode[s['index']]
            ox = (gap + exp) * math.cos(mid_rad) + 10
            oy = (gap + exp) * math.sin(mid_rad) + 12
            sc = (center[0] + ox, center[1] + oy + depth)
            self.ctx.move_to(*sc)
            self.ctx.arc(*sc, radius * 1.01, math.radians(s['start']), math.radians(s['start'] + s['sweep']))
            self.ctx.close_path()
            self.ctx.set_source_rgba(0, 0, 0, 0.18)
            self.ctx.fill()
        
        for s in draw_order:
            idx = s['index']
            top, side = Colors.get_pie_colors(idx)
            exp = explode[idx]
            mid_rad = math.radians(s['start'] + s['sweep'] / 2)
            ox = (gap + exp) * math.cos(mid_rad)
            oy = (gap + exp) * math.sin(mid_rad)
            sc = (center[0] + ox, center[1] + oy)
            
            start_rad = math.radians(s['start'])
            end_rad = math.radians(s['start'] + s['sweep'])
            segments = max(2, int(s['sweep'] / 4))
            for i in range(segments):
                a1 = start_rad + (end_rad - start_rad) * i / segments
                a2 = start_rad + (end_rad - start_rad) * (i + 1) / segments
                mid_a = (a1 + a2) / 2
                if math.sin(mid_a) < 0: continue
                x1 = sc[0] + radius * math.cos(a1)
                y1_top = sc[1] + radius * math.sin(a1)
                x2 = sc[0] + radius * math.cos(a2)
                y2_top = sc[1] + radius * math.sin(a2)
                self.ctx.move_to(x1, y1_top)
                self.ctx.line_to(x2, y2_top)
                self.ctx.line_to(x2, y2_top + depth)
                self.ctx.line_to(x1, y1_top + depth)
                self.ctx.close_path()
                brightness = 0.7 + 0.3 * (1 - math.sin(mid_a))
                self.ctx.set_source_rgb(*(c * brightness for c in side))
                self.ctx.fill()
            
            self.ctx.move_to(*sc)
            self.ctx.arc(*sc, radius, start_rad, end_rad)
            self.ctx.close_path()
            self.ctx.set_source_rgb(*top)
            self.ctx.fill_preserve()
            grad = cairo.RadialGradient(sc[0] - radius*0.3, sc[1] - radius*0.3, 0, sc[0], sc[1], radius)
            grad.add_color_stop_rgba(0, 1, 1, 1, 0.45)
            grad.add_color_stop_rgba(0.35, 1, 1, 1, 0.15)
            grad.add_color_stop_rgba(1, 1, 1, 1, 0)
            self.ctx.set_source(grad)
            self.ctx.move_to(*sc)
            self.ctx.arc(*sc, radius, start_rad, end_rad)
            self.ctx.close_path()
            self.ctx.fill()
        
        for s in slices:
            idx = s['index']
            exp = explode[idx]
            mid_rad = math.radians(s['start'] + s['sweep'] / 2)
            ox = (gap + exp) * math.cos(mid_rad)
            oy = (gap + exp) * math.sin(mid_rad)
            sc = (center[0] + ox, center[1] + oy)
            
            self.ctx.set_source_rgba(1, 1, 1, 0.85)
            self.ctx.set_line_width(2)
            start_rad = math.radians(s['start'])
            end_rad = math.radians(s['start'] + s['sweep'])
            self.ctx.arc(*sc, radius, start_rad, end_rad)
            self.ctx.stroke()
            
            lx = sc[0] + radius * 0.6 * math.cos(mid_rad)
            ly = sc[1] + radius * 0.6 * math.sin(mid_rad)
            text = f"{(s['value']/total)*360:.0f}°" if value_type == 'degree' else f"%{(s['value']/total)*100:.0f}"
            self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
            self.ctx.set_font_size(16)
            ext = self.ctx.text_extents(text)
            self.ctx.set_source_rgba(0, 0, 0, 0.5)
            self.ctx.move_to(lx - ext.width/2 + 1.5, ly + ext.height/2 + 1.5)
            self.ctx.show_text(text)
            self.ctx.set_source_rgb(1, 1, 1)
            self.ctx.move_to(lx - ext.width/2, ly + ext.height/2)
            self.ctx.show_text(text)
        
        if show_legend:
            self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            self.ctx.set_font_size(12)
            items = []
            for i, (lbl, val) in enumerate(zip(labels, values)):
                txt = f"{lbl} ({(val/total)*360:.0f}°)" if value_type == 'degree' else f"{lbl} (%{(val/total)*100:.0f})"
                ext = self.ctx.text_extents(txt)
                items.append((txt, ext.width, i))
            total_w = sum(w + 42 for _, w, _ in items)
            x = (self.width - total_w) / 2 + 10
            y = self.height - 38
            for txt, w, i in items:
                top, _ = Colors.get_pie_colors(i)
                self.ctx.set_source_rgb(*top)
                self.ctx.rectangle(x, y, 16, 16)
                self.ctx.fill()
                self.ctx.set_source_rgb(*Colors.GRID_DARK)
                self.ctx.move_to(x + 22, y + 13)
                self.ctx.show_text(txt)
                x += w + 42
    
    def get_png_bytes(self):
        buf = io.BytesIO()
        self.surface.write_to_png(buf)
        return buf.getvalue()


class BarChartRenderer:
    def __init__(self, width=700, height=500):
        self.width = width
        self.height = height
        self.surface = None
        self.ctx = None
    
    def setup(self, bg_color=None):
        self.surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, self.width, self.height)
        self.ctx = cairo.Context(self.surface)
        self.ctx.set_antialias(cairo.ANTIALIAS_BEST)
        if bg_color:
            self.ctx.set_source_rgb(*bg_color)
            self.ctx.paint()
    
    def draw(self, values, labels, title=None, colors=None):
        colors = colors or [Colors.get_bar_color(i) for i in range(len(values))]
        padding = 60
        if title:
            self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
            self.ctx.set_font_size(18)
            self.ctx.set_source_rgb(*Colors.GRID_DARK)
            ext = self.ctx.text_extents(title)
            self.ctx.move_to((self.width - ext.width) / 2, 35)
            self.ctx.show_text(title)
        x = padding + 30
        y = padding + (40 if title else 0)
        w = self.width - x - padding
        h = self.height - y - padding - 30
        max_val = max(values) if values else 1
        n = len(values)
        bar_w = (w / n) * 0.6
        
        self.ctx.set_source_rgb(*Colors.GRID_LIGHT)
        self.ctx.set_line_width(1)
        self.ctx.set_dash([4, 4])
        for i in range(1, 6):
            ly = y + h - (i / 5) * (h - 20)
            self.ctx.move_to(x, ly)
            self.ctx.line_to(x + w, ly)
            self.ctx.stroke()
        self.ctx.set_dash([])
        
        self.ctx.set_source_rgb(*Colors.GRID_DARK)
        self.ctx.set_line_width(2)
        self.ctx.move_to(x, y + h)
        self.ctx.line_to(x + w, y + h)
        self.ctx.stroke()
        
        for i, (val, lbl) in enumerate(zip(values, labels)):
            bar_h = (val / max_val) * (h - 20) if max_val > 0 else 0
            bx = x + i * (w / n) + (w / n - bar_w) / 2
            by = y + h - bar_h
            self.ctx.set_source_rgba(0, 0, 0, 0.15)
            self._rounded_rect(bx + 3, by + 3, bar_w, bar_h, 4)
            self.ctx.fill()
            self.ctx.set_source_rgb(*colors[i % len(colors)])
            self._rounded_rect(bx, by, bar_w, bar_h, 4)
            self.ctx.fill()
            self.ctx.select_font_face("Arial", cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
            self.ctx.set_font_size(12)
            self.ctx.set_source_rgb(*Colors.GRID_DARK)
            val_text = str(int(val)) if val == int(val) else f"{val:.1f}"
            ext = self.ctx.text_extents(val_text)
            self.ctx.move_to(bx + bar_w/2 - ext.width/2, by - 8)
            self.ctx.show_text(val_text)
            self.ctx.set_font_size(11)
            ext = self.ctx.text_extents(lbl)
            self.ctx.move_to(bx + bar_w/2 - ext.width/2, y + h + 20)
            self.ctx.show_text(lbl)
    
    def _rounded_rect(self, x, y, w, h, r):
        if h <= 0: return
        r = min(r, w/2, h/2)
        self.ctx.new_path()
        self.ctx.arc(x+r, y+r, r, math.pi, 1.5*math.pi)
        self.ctx.arc(x+w-r, y+r, r, 1.5*math.pi, 2*math.pi)
        self.ctx.arc(x+w-r, y+h-r, r, 0, 0.5*math.pi)
        self.ctx.arc(x+r, y+h-r, r, 0.5*math.pi, math.pi)
        self.ctx.close_path()
    
    def get_png_bytes(self):
        buf = io.BytesIO()
        self.surface.write_to_png(buf)
        return buf.getvalue()


class SupabaseManager:
    def __init__(self):
        if not Config.SUPABASE_URL or not Config.SUPABASE_KEY:
            raise ValueError("Supabase credentials eksik!")
        self.client = create_client(Config.SUPABASE_URL, Config.SUPABASE_KEY)
        logger.info("Supabase bağlantısı kuruldu")
    
    def get_questions_without_images(self, limit=30):
        """Görselsiz geometri sorularını çek - şemaya uygun"""
        try:
            # Geometri konularını filtrele (topic sütununda)
            geometry_topics = [
                'Geometri', 'Üçgen', 'Dörtgen', 'Çember', 'Daire', 
                'Alan', 'Çevre', 'Hacim', 'Açı', 'Koordinat',
                'Prizma', 'Piramit', 'Silindir', 'Koni', 'Küre'
            ]
            
            # İlk önce topic'te geometri olanları dene
            for geo_topic in geometry_topics[:5]:  # İlk 5 konuyu dene
                result = self.client.table('question_bank').select(
                    'id', 'original_text', 'topic', 'topic_group', 'grade_level', 'image_url'
                ).is_('image_url', 'null').eq('is_active', True).ilike(
                    'topic', f'%{geo_topic}%'
                ).limit(limit).execute()
                
                if result.data and len(result.data) > 0:
                    logger.info(f"Geometri sorgusu ({geo_topic}): {len(result.data)} soru bulundu")
                    return result.data
            
            # Alternatif: original_text'te geometri anahtar kelimeleri ara
            geometry_keywords = ['üçgen', 'ABC', 'ABCD', 'açı', 'kenar', 'çember', 'daire', 'kare', 'dikdörtgen']
            for kw in geometry_keywords[:3]:
                result = self.client.table('question_bank').select(
                    'id', 'original_text', 'topic', 'topic_group', 'grade_level', 'image_url'
                ).is_('image_url', 'null').eq('is_active', True).ilike(
                    'original_text', f'%{kw}%'
                ).limit(limit).execute()
                
                if result.data and len(result.data) > 0:
                    logger.info(f"Anahtar kelime sorgusu ({kw}): {len(result.data)} soru bulundu")
                    return result.data
            
            # Fallback: tüm görselsiz sorular
            logger.info("Geometri filtresi sonuç vermedi, tüm sorular çekiliyor")
            result = self.client.table('question_bank').select(
                'id', 'original_text', 'topic', 'topic_group', 'grade_level', 'image_url'
            ).is_('image_url', 'null').eq('is_active', True).limit(limit).execute()
            
            return result.data if result.data else []
            
        except Exception as e:
            logger.error(f"Sorgu hatası: {e}")
            return []
    
    def update_question_image(self, question_id, image_url):
        """Soru görselini güncelle - şemaya uygun"""
        try:
            self.client.table('question_bank').update({
                'image_url': image_url
            }).eq('id', question_id).execute()
            logger.info(f"Soru {question_id} güncellendi")
            return True
        except Exception as e:
            logger.error(f"Güncelleme hatası (id={question_id}): {e}")
            return False
    
    def upload_image(self, image_bytes, filename):
        try:
            self.client.storage.from_(Config.STORAGE_BUCKET).upload(path=filename, file=image_bytes, file_options={"content-type": "image/png"})
            return self.client.storage.from_(Config.STORAGE_BUCKET).get_public_url(filename)
        except Exception as e:
            if 'Duplicate' in str(e):
                try:
                    self.client.storage.from_(Config.STORAGE_BUCKET).update(path=filename, file=image_bytes, file_options={"content-type": "image/png"})
                    return self.client.storage.from_(Config.STORAGE_BUCKET).get_public_url(filename)
                except: pass
            logger.error(f"Upload hatası: {e}")
            return None


class GeminiAnalyzer:
    ANALYSIS_PROMPT = """Sen geometri ve veri görselleştirme uzmanısın. Soruyu analiz et ve çizim talimatı üret.

## ÇİZİM GEREKLİ (cizim_pisinilir: true):
- Geometrik şekil: üçgen, dörtgen, kare, dikdörtgen, daire, çember
- 3D cisim: küp, prizma, piramit, silindir, koni, küre
- Veri görselleştirme: pasta grafik, sütun grafik

## ÇİZİM GEREKMİYOR (cizim_pisinilir: false):
- Sayısal hesaplama, hikaye problemi (şekil çizimi gerektirmeyen)

## KRİTİK: 
- 2D şekiller için "points" listesi ZORUNLU (x,y koordinatları)
- 3D cisimler için "dimensions" objesi ZORUNLU
- Sadece JSON döndür!

## ÖRNEKLER:

2D Üçgen:
{"cizim_pisinilir": true, "shape_type": "triangle", "points": [{"name": "A", "x": 0, "y": 0}, {"name": "B", "x": 6, "y": 0}, {"name": "C", "x": 3, "y": 5}], "edges": [{"start": "A", "end": "B", "label": "6 cm"}]}

2D Dikdörtgen:
{"cizim_pisinilir": true, "shape_type": "rectangle", "points": [{"name": "A", "x": 0, "y": 0}, {"name": "B", "x": 8, "y": 0}, {"name": "C", "x": 8, "y": 5}, {"name": "D", "x": 0, "y": 5}]}

2D Daire:
{"cizim_pisinilir": true, "shape_type": "circle", "center": {"name": "O", "x": 5, "y": 5}, "radius": 4}

3D Küp:
{"cizim_pisinilir": true, "shape_type": "cube", "dimensions": {"size": 4}}

3D Piramit:
{"cizim_pisinilir": true, "shape_type": "pyramid", "dimensions": {"base_size": 4, "height": 5}}

3D Silindir:
{"cizim_pisinilir": true, "shape_type": "cylinder", "dimensions": {"radius": 3, "height": 6}}

3D Koni:
{"cizim_pisinilir": true, "shape_type": "cone", "dimensions": {"radius": 3, "height": 5}}

3D Küre:
{"cizim_pisinilir": true, "shape_type": "sphere", "dimensions": {"radius": 4}}

3D Prizma:
{"cizim_pisinilir": true, "shape_type": "rectangular_prism", "dimensions": {"width": 4, "height": 3, "depth": 2}}

Pasta Grafik:
{"cizim_pisinilir": true, "shape_type": "pie_chart", "pie_data": {"values": [40, 30, 20, 10], "labels": ["A", "B", "C", "D"], "value_type": "percent"}}

Sütun Grafik:
{"cizim_pisinilir": true, "shape_type": "bar_chart", "bar_data": {"values": [25, 40, 35], "labels": ["X", "Y", "Z"]}}

Çizim Yok:
{"cizim_pisinilir": false, "neden": "Hesaplama"}

SORU: """
    
    def __init__(self):
        if not Config.GEMINI_API_KEY:
            raise ValueError("Gemini API key eksik!")
        if NEW_GENAI:
            self.client = genai.Client(api_key=Config.GEMINI_API_KEY)
        else:
            genai.configure(api_key=Config.GEMINI_API_KEY)
            self.model = genai.GenerativeModel(Config.GEMINI_MODEL)
        self.request_count = 0
        self.last_request_time = 0
        self.requests_per_minute = 8  # 10'dan biraz düşük tut güvenlik için
        logger.info(f"Gemini bağlantısı kuruldu (model: {Config.GEMINI_MODEL})")
    
    def _rate_limit(self):
        """Rate limiting - dakikada max istek sayısını kontrol et"""
        current_time = time.time()
        
        # Her dakika başında sayacı sıfırla
        if current_time - self.last_request_time > 60:
            self.request_count = 0
            self.last_request_time = current_time
        
        # Limit aşıldıysa bekle
        if self.request_count >= self.requests_per_minute:
            wait_time = 60 - (current_time - self.last_request_time) + 2  # +2 güvenlik marjı
            if wait_time > 0:
                logger.info(f"⏳ Rate limit - {wait_time:.0f} saniye bekleniyor...")
                time.sleep(wait_time)
                self.request_count = 0
                self.last_request_time = time.time()
        
        self.request_count += 1
    
    def analyze(self, question_text, max_retries=3):
        for attempt in range(max_retries):
            try:
                self._rate_limit()
                prompt = self.ANALYSIS_PROMPT + question_text
                
                if NEW_GENAI:
                    response = self.client.models.generate_content(model=Config.GEMINI_MODEL, contents=prompt)
                    text = response.text
                else:
                    response = self.model.generate_content(prompt)
                    text = response.text
                
                text = text.strip()
                if text.startswith('```'):
                    lines = text.split('\n')
                    text = '\n'.join(lines[1:-1])
                    if text.startswith('json'): text = text[4:].strip()
                return json.loads(text)
                
            except Exception as e:
                error_str = str(e)
                if '429' in error_str or 'RESOURCE_EXHAUSTED' in error_str:
                    # Rate limit hatası - bekle ve tekrar dene
                    wait_time = 60 + (attempt * 10)  # Her denemede daha uzun bekle
                    logger.warning(f"⚠️ Rate limit aşıldı. {wait_time}s bekleniyor... (deneme {attempt + 1}/{max_retries})")
                    time.sleep(wait_time)
                    self.request_count = 0  # Sayacı sıfırla
                    self.last_request_time = time.time()
                else:
                    logger.error(f"Gemini hatası: {e}")
                    return None
        
        logger.error(f"Gemini: {max_retries} deneme sonrası başarısız")
        return None


class ImageGenerator:
    def generate(self, analysis):
        shape_type = analysis.get('shape_type', '')
        logger.info(f"ImageGenerator: shape_type={shape_type}")
        
        # 3D şekil tipleri
        three_d_shapes = ['cube', 'pyramid', 'cylinder', 'sphere', 'cone', 'prism', 
                         'rectangular_prism', 'triangular_prism']
        
        try:
            if shape_type == 'pie_chart': 
                return self._pie(analysis)
            elif shape_type == 'bar_chart': 
                return self._bar(analysis)
            elif shape_type in three_d_shapes:
                return self._render_3d(analysis)
            else: 
                return self._geometry(analysis)
        except Exception as e:
            logger.error(f"ImageGenerator hata: {e}")
            import traceback
            logger.error(traceback.format_exc())
            return None
    
    def _render_3d(self, analysis):
        """3D şekilleri render et"""
        shape_type = analysis.get('shape_type', '')
        dimensions = analysis.get('dimensions', {})
        
        renderer = Cube3DRenderer(800, 700)
        if not renderer.setup():
            logger.warning("3D renderer başlatılamadı (matplotlib eksik olabilir)")
            return None
        
        try:
            if shape_type == 'cube':
                size = dimensions.get('size', dimensions.get('edge', 4))
                renderer.draw_cube(size=size, edge_label=f"{size} cm")
            
            elif shape_type == 'rectangular_prism' or shape_type == 'prism':
                w = dimensions.get('width', 4)
                h = dimensions.get('height', 3)
                d = dimensions.get('depth', 2)
                renderer.draw_rectangular_prism(w, h, d)
            
            elif shape_type == 'cylinder':
                r = dimensions.get('radius', 2)
                h = dimensions.get('height', 4)
                renderer.draw_cylinder(radius=r, height=h)
            
            elif shape_type == 'sphere':
                r = dimensions.get('radius', 3)
                renderer.draw_sphere(radius=r)
            
            elif shape_type == 'cone':
                r = dimensions.get('radius', 2)
                h = dimensions.get('height', 4)
                renderer.draw_cone(radius=r, height=h)
            
            elif shape_type == 'pyramid':
                base = dimensions.get('base_size', dimensions.get('base', 4))
                h = dimensions.get('height', 5)
                sides = dimensions.get('sides', 4)
                renderer.draw_pyramid(base_size=base, height=h, n_sides=sides)
            
            elif shape_type == 'triangular_prism':
                base = dimensions.get('base_size', 3)
                h = dimensions.get('height', 5)
                renderer.draw_triangular_prism(base_size=base, height=h)
            
            else:
                # Varsayılan: küp
                renderer.draw_cube(size=4)
            
            logger.info(f"3D şekil oluşturuldu: {shape_type}")
            return renderer.get_png_bytes()
            
        except Exception as e:
            logger.error(f"3D render hatası: {e}")
            return None
    
    def _pie(self, analysis):
        pd = analysis.get('pie_data', {})
        if not pd.get('values'): 
            logger.warning("Pie chart: values eksik")
            return None
        r = Pie3DRenderer(700, 620)
        r.setup(bg_color=Colors.WHITE)
        r.draw(values=pd.get('values', []), labels=pd.get('labels', []), title=pd.get('title'),
               value_type=pd.get('value_type', 'percent'), explode=pd.get('explode'), depth=50, gap=10)
        return r.get_png_bytes()
    
    def _bar(self, analysis):
        bd = analysis.get('bar_data', {})
        if not bd.get('values'): 
            logger.warning("Bar chart: values eksik")
            return None
        r = BarChartRenderer(700, 500)
        r.setup(bg_color=Colors.WHITE)
        r.draw(values=bd.get('values', []), labels=bd.get('labels', []), title=bd.get('title'))
        return r.get_png_bytes()
    
    def _geometry(self, analysis):
        shape_type = analysis.get('shape_type', '')
        
        # Circle için özel işlem
        if shape_type == 'circle':
            return self._circle(analysis)
        
        pts = analysis.get('points', [])
        if not pts: 
            logger.warning("Geometry: points eksik")
            return None
        logger.info(f"Geometry: {len(pts)} nokta")
        xs, ys = [p['x'] for p in pts], [p['y'] for p in pts]
        bounds = {'x_min': min(xs)-2, 'x_max': max(xs)+2, 'y_min': min(ys)-2, 'y_max': max(ys)+2}
        r = CairoRenderer(Config.IMAGE_WIDTH, Config.IMAGE_HEIGHT)
        r.setup(bounds)
        points = {p['name']: (p['x'], p['y']) for p in pts}
        for name, pos in points.items(): r.add_point(name, *pos)
        for circle in analysis.get('circles', []):
            if 'center' in circle and 'radius' in circle:
                r.draw_circle(circle['center'], circle['radius'], Colors.FILL_LIGHT, Colors.PRIMARY)
        if len(pts) >= 3:
            coords = [(p['x'], p['y']) for p in pts]
            r.draw_polygon(coords, Colors.FILL_LIGHT, Colors.PRIMARY, stroke_width=3)
        for sl in analysis.get('special_lines', []):
            from_name = sl.get('from')
            if from_name:
                from_idx = ord(from_name) - ord('A')
                if 0 <= from_idx < len(pts) and len(pts) >= 3:
                    coords = [(p['x'], p['y']) for p in pts[:3]]
                    if sl['type'] == 'height': r.draw_altitude(coords, from_idx, label=sl.get('label'))
                    elif sl['type'] == 'median': r.draw_median(coords, from_idx, label=sl.get('label'))
                    elif sl['type'] == 'bisector': r.draw_angle_bisector(coords, from_idx, label=sl.get('label'))
        for ang in analysis.get('angles', []):
            v_name = ang.get('vertex')
            if v_name and v_name in points:
                vertex = points[v_name]
                idx = next((i for i, p in enumerate(pts) if p['name'] == v_name), -1)
                if idx >= 0 and len(pts) >= 3:
                    p1 = (pts[(idx-1) % len(pts)]['x'], pts[(idx-1) % len(pts)]['y'])
                    p2 = (pts[(idx+1) % len(pts)]['x'], pts[(idx+1) % len(pts)]['y'])
                    if ang.get('is_right'): r.draw_right_angle(vertex, p1, p2)
                    elif ang.get('value'): r.draw_angle_arc(vertex, p1, p2, label=ang['value'], fill=True)
        for edge in analysis.get('edges', []):
            s, e, label = edge.get('start'), edge.get('end'), edge.get('label')
            if s in points and e in points and label:
                p1, p2 = points[s], points[e]
                mid = ((p1[0]+p2[0])/2, (p1[1]+p2[1])/2)
                ev = np.array(p2) - np.array(p1)
                normal = np.array([-ev[1], ev[0]])
                nl = np.linalg.norm(normal)
                if nl > 0: normal = normal / nl * 0.5
                r.draw_label((mid[0]+normal[0], mid[1]+normal[1]), label, Colors.PRIMARY)
        for i, p in enumerate(pts):
            color = Colors.get_point_color(i)
            pos = (p['x'], p['y'])
            r.draw_point(pos, color)
            r.draw_point_label(pos, p['name'], color, p.get('label_position', 'auto'))
        return r.get_png_bytes()
    
    def _circle(self, analysis):
        """Daire/çember çiz"""
        center_data = analysis.get('center', {})
        radius = analysis.get('radius', 4)
        
        cx = center_data.get('x', 5)
        cy = center_data.get('y', 5)
        center_name = center_data.get('name', 'O')
        
        # Bounds hesapla
        bounds = {
            'x_min': cx - radius - 2,
            'x_max': cx + radius + 2,
            'y_min': cy - radius - 2,
            'y_max': cy + radius + 2
        }
        
        r = CairoRenderer(Config.IMAGE_WIDTH, Config.IMAGE_HEIGHT)
        r.setup(bounds)
        
        # Çember çiz
        r.draw_circle((cx, cy), radius, Colors.FILL_LIGHT, Colors.PRIMARY, stroke_width=3)
        
        # Merkez noktası
        r.draw_point((cx, cy), Colors.get_point_color(0))
        r.draw_point_label((cx, cy), center_name, Colors.get_point_color(0))
        
        # Yarıçap çizgisi
        r.draw_line((cx, cy), (cx + radius, cy), Colors.SECONDARY, width=2)
        r.draw_label((cx + radius/2, cy + 0.3), f"r={radius}", Colors.SECONDARY)
        
        # Ek noktalar varsa
        for i, p in enumerate(analysis.get('points', [])):
            pos = (p['x'], p['y'])
            color = Colors.get_point_color(i + 1)
            r.draw_point(pos, color)
            r.draw_point_label(pos, p['name'], color)
        
        logger.info(f"Circle: center=({cx},{cy}), radius={radius}")
        return r.get_png_bytes()


class GeometryBot:
    def __init__(self):
        logger.info("=" * 60)
        logger.info("Geometry Bot v3.0 - Cairo")
        logger.info("=" * 60)
        self.supabase = SupabaseManager()
        self.analyzer = GeminiAnalyzer()
        self.generator = ImageGenerator()
        self.stats = {'processed': 0, 'success': 0, 'skipped': 0, 'error': 0, 'start_time': datetime.now()}
    
    def run(self):
        logger.info("Bot başlatılıyor...")
        batch = 10 if Config.TEST_MODE else Config.BATCH_SIZE
        questions = self.supabase.get_questions_without_images(batch)
        if not questions:
            logger.info("İşlenecek soru yok")
            return
        logger.info(f"{len(questions)} soru işlenecek")
        for i, q in enumerate(questions, 1):
            self._process(q)
            if i < len(questions): time.sleep(1)
        elapsed = datetime.now() - self.stats['start_time']
        logger.info(f"Süre: {elapsed}, Başarılı: {self.stats['success']}/{self.stats['processed']}")
    
    def _process(self, question):
        q_id = question.get('id')
        q_text = question.get('original_text', '')
        
        if not q_text:
            logger.warning(f"[{q_id}] ⏭️ Soru metni boş")
            self.stats['skipped'] += 1
            return
        
        logger.info(f"[{q_id}] 📝 İşleniyor: {q_text[:80]}...")
        self.stats['processed'] += 1
        
        try:
            analysis = self.analyzer.analyze(q_text)
            
            if not analysis:
                logger.warning(f"[{q_id}] ❌ Gemini analiz döndürmedi")
                self.stats['error'] += 1
                return
            
            logger.info(f"[{q_id}] 🔍 Analiz: cizim={analysis.get('cizim_pisinilir')}, type={analysis.get('shape_type', 'N/A')}")
            
            if not analysis.get('cizim_pisinilir', False):
                reason = analysis.get('neden', 'belirtilmedi')
                logger.info(f"[{q_id}] ⏭️ Çizim gerekmiyor: {reason}")
                self.stats['skipped'] += 1
                return
            
            image_bytes = self.generator.generate(analysis)
            
            if not image_bytes:
                logger.warning(f"[{q_id}] ❌ Görsel oluşturulamadı - shape_type: {analysis.get('shape_type')}")
                logger.debug(f"[{q_id}] Full analysis: {json.dumps(analysis, ensure_ascii=False)}")
                self.stats['error'] += 1
                return
            
            logger.info(f"[{q_id}] 🎨 Görsel oluşturuldu ({len(image_bytes)} bytes)")
            
            filename = f"geometry_{q_id}_{int(time.time())}.png"
            image_url = self.supabase.upload_image(image_bytes, filename)
            
            if image_url and self.supabase.update_question_image(q_id, image_url):
                logger.info(f"[{q_id}] ✅ Başarılı: {image_url}")
                self.stats['success'] += 1
            else:
                logger.warning(f"[{q_id}] ❌ Yükleme/güncelleme başarısız")
                self.stats['error'] += 1
                
        except Exception as e:
            logger.error(f"[{q_id}] ❌ Hata: {e}")
            import traceback
            logger.error(traceback.format_exc())
            self.stats['error'] += 1


if __name__ == "__main__":
    GeometryBot().run()
